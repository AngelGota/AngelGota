name: 4. Auto-merge si hay 1 comentario + 1 approve

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read
  issues: read

jobs:
  scan-and-merge:
    runs-on: ubuntu-latest
    env:
      REPO: ${{ github.repository }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # para gh api/merge
      GH_PAT:   ${{ secrets.GH_PAT }}         # merge como tu usuario (recomendado)
      RESOLUTION_POLICY: keep-main            # keep-main | keep-feature
      GIT_AUTHOR_NAME:  AngelGota
      GIT_AUTHOR_EMAIL: gangelos630@gmail.com
    steps:
      - name: Asegurar GH CLI y jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq gh git
          gh --version

      - name: Verificar PRs abiertos y mergear si cumplen
        shell: bash
        run: |
          set -euo pipefail
          OWNER_REPO="${REPO}"
          echo "üîç Buscando PRs abiertos en $OWNER_REPO..."

          mapfile -t PRS < <(gh api "repos/${OWNER_REPO}/pulls?state=open&per_page=100" \
                              --jq '.[] | select(.draft==false) | .number')
          [[ ${#PRS[@]} -eq 0 ]] && { echo "No hay PRs abiertos (no draft)."; exit 0; }

          wait_checks () {
            local sha="$1" tries=0 max=90   # 90 * 2s = 3 min
            while :; do
              # combined status (puede quedar "pending")
              local combined; combined=$(gh api "repos/${OWNER_REPO}/commits/${sha}/status" --jq '.state // "empty"' || echo "empty")

              # check-runs (API nueva)
              local total failed pending running success_like
              total=$(gh api -H "Accept: application/vnd.github+json" \
                        "repos/${OWNER_REPO}/commits/${sha}/check-runs" --jq '.total_count' || echo 0)

              failed=$(gh api -H "Accept: application/vnd.github+json" \
                        "repos/${OWNER_REPO}/commits/${sha}/check-runs" \
                        --jq '[.check_runs[].conclusion] | map(select(.=="failure" or .=="timed_out" or .=="cancelled" or .=="action_required")) | length' || echo 0)

              # en progreso (queued/in_progress)
              pending=$(gh api -H "Accept: application/vnd.github+json" \
                        "repos/${OWNER_REPO}/commits/${sha}/check-runs" \
                        --jq '[.check_runs[].status] | map(select(.=="queued" or .=="in_progress")) | length' || echo 0)

              # √©xitos o neutrales (√©xitos + skipped + neutral)
              success_like=$(gh api -H "Accept: application/vnd.github+json" \
                        "repos/${OWNER_REPO}/commits/${sha}/check-runs" \
                        --jq '[.check_runs[].conclusion] | map(select(.=="success" or .=="neutral" or .=="skipped")) | length' || echo 0)

              echo "checks: combined=$combined, total=${total:-0}, failed=${failed:-0}, pending=${pending:-0}, ok_like=${success_like:-0}"

              # si hay alg√∫n fallo -> no mergear
              if [[ ${failed:-0} -gt 0 ]]; then
                return 1
              fi

              # si combined=success -> ok
              if [[ "$combined" == "success" ]]; then
                return 0
              fi

              # si no quedan en progreso y no hay fallos -> ok (aunque combined sea pending)
              if [[ ${pending:-0} -eq 0 && ${failed:-0} -eq 0 && ${total:-0} -ge 0 ]]; then
                # opcionalmente pide al menos 1 success/neutral/skipped
                if [[ ${success_like:-0} -ge 1 || ${total:-0} -eq 0 ]]; then
                  return 0
                fi
              fi

              ((tries++))
              if [[ $tries -ge $max ]]; then
                echo "‚è±Ô∏è Timeout con combined=$combined; failed=${failed:-0}, pending=${pending:-0}"
                # si no hay fallos, permitimos continuar
                [[ ${failed:-0} -eq 0 ]] && return 0 || return 1
              fi
              sleep 2
            done
          }

          wait_mergeable () {
            local pr="$1" tries=0 max=30
            while :; do
              local ms; ms=$(gh api "repos/${OWNER_REPO}/pulls/${pr}" --jq '.mergeable_state // "unknown"')
              [[ "$ms" != "unknown" ]] && { echo "$ms"; return 0; }
              ((tries++)); [[ $tries -ge $max ]] && { echo "unknown"; return 0; }
              sleep 1
            done
          }

            auto_resolve_conflicts () {
              # Args: PR_NUMBER HEAD_REF BASE_REF (main)
              local pr="$1" head="$2" base="$3"

              echo "üß© Intentando resoluci√≥n autom√°tica (policy=${RESOLUTION_POLICY}) para PR #$pr (${head} -> ${base})"

              git config --global user.name  "${GIT_AUTHOR_NAME}"
              git config --global user.email "${GIT_AUTHOR_EMAIL}"

              # Clonado limpio y autenticado (para poder pushear a la rama del PR)
              rm -rf repo
              git init repo
              cd repo
              git remote add origin "https://x-access-token:${GH_PAT}@github.com/${OWNER_REPO}.git"

              # Traer solo lo necesario (sin tags, sin blobs completos)
              git -c protocol.version=2 fetch --no-tags --filter=blob:none origin "$base" "$head"
              git checkout -B "$head" "origin/$head"

              # Elegir estrategia: recuerda que estamos parados en la rama del PR (HEAD=$head)
              case "$RESOLUTION_POLICY" in
                keep-main)    STRAT="-X theirs" ;;   # Mantiene MAIN (lo que se trae)
                keep-feature) STRAT="-X ours"  ;;    # Mantiene FEATURE (la rama actual)
                *)            STRAT="-X theirs" ;;
              esac

              set +e
              git merge $STRAT "origin/$base" -m "chore(auto): resolve conflicts (${RESOLUTION_POLICY})" >/tmp/merge.log 2>&1
              rc=$?
              set -e

              if [[ $rc -ne 0 ]]; then
                echo "‚ùå git merge fall√≥. Log (primeros 200):"
                sed -n '1,200p' /tmp/merge.log || true
                # Si quedaron archivos en conflicto, los aceptamos seg√∫n la pol√≠tica y cerramos
                if git ls-files -u | grep -q .; then
                  if [[ "$RESOLUTION_POLICY" == "keep-main" ]]; then
                    # aceptar 'theirs' (main) para todos los conflictos
                    git checkout --theirs .
                  else
                    # aceptar 'ours' (feature) para todos los conflictos
                    git checkout --ours .
                  fi
                  git add -A
                  git commit -m "chore(auto): finalize conflict resolution (${RESOLUTION_POLICY})"
                else
                  cd ..
                  return 1
                fi
              fi

              # Push a la rama del PR
              git push origin "HEAD:$head"
              cd ..
              echo "‚úÖ Conflictos resueltos y empujados a $head"
              return 0
            }

          for PR in "${PRS[@]}"; do
            echo "---- Evaluando PR #$PR ----"

            COMMENTS_ISSUE=$(gh api "repos/${OWNER_REPO}/issues/${PR}/comments?per_page=100" --jq 'length')
            COMMENTS_REVIEW=$(gh api "repos/${OWNER_REPO}/pulls/${PR}/comments?per_page=100" --jq 'length')
            COMMENTS=$(( COMMENTS_ISSUE + COMMENTS_REVIEW ))

            APPROVALS=$(gh api "repos/${OWNER_REPO}/pulls/${PR}/reviews?per_page=100" \
              --jq 'group_by(.user.login) | map(.[-1].state) | map(select(.=="APPROVED")) | length')

            SHA=$(gh api "repos/${OWNER_REPO}/pulls/${PR}" --jq .head.sha)
            HEAD_REF=$(gh api "repos/${OWNER_REPO}/pulls/${PR}" --jq .head.ref)
            BASE_REF=$(gh api "repos/${OWNER_REPO}/pulls/${PR}" --jq .base.ref)

            # Espera checks del commit actual
            if ! wait_checks "$SHA"; then
              echo "‚è≠ Checks a√∫n no OK. Se omite por ahora."
              continue
            fi

            MERGEABLE_STATE=$(wait_mergeable "$PR")
            echo "üìä Comentarios: $COMMENTS | Approvals: $APPROVALS | Mergeable: $MERGEABLE_STATE"

            # Si est√° dirty, intentamos resolver autom√°ticamente y re-evaluamos
            if [[ "$MERGEABLE_STATE" == "dirty" ]]; then
              if auto_resolve_conflicts "$PR" "$HEAD_REF" "$BASE_REF"; then
                # nuevo SHA tras push
                NEW_SHA=$(gh api "repos/${OWNER_REPO}/pulls/${PR}" --jq .head.sha)
                wait_checks "$NEW_SHA" || true
                MERGEABLE_STATE=$(wait_mergeable "$PR")
                echo "üîÅ Mergeable tras resolver: $MERGEABLE_STATE"
              else
                echo "‚õî No se pudo resolver autom√°ticamente. Se omite."
                continue
              fi
            fi

            # Reglas para merge
            if [[ "$COMMENTS" -ge 1 && "$APPROVALS" -ge 1 ]]; then
              case "$MERGEABLE_STATE" in
                clean|unstable|has_hooks)
                  echo "‚úÖ Cumple criterios. Mergeando (squash + delete branch)..."
                  if [[ -z "${GH_PAT:-}" ]]; then
                    echo "‚ùå GH_PAT no configurado. Crea el secret GH_PAT para mergear como tu usuario."
                    exit 1
                  fi
                  TITLE=$(gh api "repos/${OWNER_REPO}/pulls/${PR}" --jq .title)
                  GH_TOKEN="$GH_PAT" gh pr merge "$PR" --repo "$OWNER_REPO" --squash --delete-branch --subject "$TITLE"
                  gh pr comment "$PR" --repo "$OWNER_REPO" --body \
                    "‚úÖ **GotaBot:** Merge autom√°tico (1+ comentario, 1+ approval, checks OK)."
                  ;;
                blocked|dirty|unknown)
                  echo "‚õî A√∫n no mergeable (estado: $MERGEABLE_STATE)."
                  ;;
                *)
                  echo "‚õî Estado no contemplado: $MERGEABLE_STATE."
                  ;;
              esac
            else
              echo "‚è≠ No cumple m√≠nimos (comentarios>=1 y approvals>=1)."
            fi
          done
