name: 4. Auto-merge si hay 1 comentario + 1 approve

on:
  schedule:
    - cron: "*/5 * * * *"   # cada 5 minutos
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read
  issues: read

jobs:
  scan-and-merge:
    runs-on: ubuntu-latest
    env:
      REPO: ${{ github.repository }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # lecturas
      GH_PAT:   ${{ secrets.GH_PAT }}         # merge como tu usuario
    steps:
      - name: Asegurar GH CLI y jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq gh
          gh --version

      - name: Verificar PRs abiertos y mergear si cumplen
        shell: bash
        run: |
          set -euo pipefail

          OWNER_REPO="${REPO}"
          echo "üîç Buscando PRs abiertos en $OWNER_REPO..."

          # PRs abiertos que no son draft
          mapfile -t PRS < <(gh api "repos/${OWNER_REPO}/pulls?state=open&per_page=100" \
                              --jq '.[] | select(.draft==false) | .number')
          [[ ${#PRS[@]} -eq 0 ]] && { echo "No hay PRs abiertos (no draft)."; exit 0; }

          wait_checks () {
            local sha="$1" tries=0 max=60
            while :; do
              # combined status (old API)
              local st; st=$(gh api "repos/${OWNER_REPO}/commits/${sha}/status" --jq .state)
              # checks v3 (new API)
              local total failure_count
              total=$(gh api -H "Accept: application/vnd.github+json" \
                        "repos/${OWNER_REPO}/commits/${sha}/check-runs" --jq '.total_count')
              failure_count=$(gh api -H "Accept: application/vnd.github+json" \
                        "repos/${OWNER_REPO}/commits/${sha}/check-runs" \
                        --jq '[.check_runs[].conclusion] | map(select(.=="failure" or .=="timed_out" or .=="cancelled")) | length')

              if [[ "$st" == "success" ]] || { [[ "${total:-0}" -gt 0 ]] && [[ "${failure_count:-0}" -eq 0 ]]; }; then
                echo "‚úÖ Checks OK (state=$st, failures=${failure_count:-0})"
                return 0
              fi

              ((tries++))
              if [[ $tries -ge $max ]]; then
                echo "‚è±Ô∏è Timeout esperando checks (state=$st)."
                return 1
              fi
              sleep 2
            done
          }

            wait_mergeable () {
              local pr="$1" tries=0 max=30
              while :; do
                local ms; ms=$(gh api "repos/${OWNER_REPO}/pulls/${pr}" --jq .mergeable_state)
                if [[ "$ms" != "unknown" && -n "$ms" ]]; then
                  echo "$ms"   # <-- deja solo esto (quita el echo anterior con el √≠cono)
                  return 0
                fi
                ((tries++))
                [[ $tries -ge $max ]] && { echo "unknown"; return 0; }
                sleep 1
              done
            }
                

          for PR in "${PRS[@]}"; do
            echo "---- Evaluando PR #$PR ----"

            # Comentarios: hilo del PR (issues) + comentarios de review (en diffs)
            COMMENTS_ISSUE=$(gh api "repos/${OWNER_REPO}/issues/${PR}/comments?per_page=100" --jq 'length')
            COMMENTS_REVIEW=$(gh api "repos/${OWNER_REPO}/pulls/${PR}/comments?per_page=100" --jq 'length')
            COMMENTS=$(( COMMENTS_ISSUE + COMMENTS_REVIEW ))

            # Aprobaciones: √∫ltimo estado por revisor
            APPROVALS=$(gh api "repos/${OWNER_REPO}/pulls/${PR}/reviews?per_page=100" \
              --jq 'group_by(.user.login) | map(.[-1].state) | map(select(.=="APPROVED")) | length')

            # SHA head
            SHA=$(gh api "repos/${OWNER_REPO}/pulls/${PR}" --jq .head.sha)

            # Esperar checks OK
            if ! wait_checks "$SHA"; then
              echo "‚è≠ Checks a√∫n no OK. Se omite por ahora."
              continue
            fi

            # mergeable_state (con espera breve para que GitHub lo calcule)
            MERGEABLE_STATE=$(wait_mergeable "$PR")

            echo "üìä Comentarios: $COMMENTS | Approvals: $APPROVALS | Mergeable: $MERGEABLE_STATE"

            if [[ "$COMMENTS" -ge 1 && "$APPROVALS" -ge 1 ]]; then
              case "$MERGEABLE_STATE" in
                clean|unstable|has_hooks)
                  echo "‚úÖ Cumple criterios. Mergeando (squash + delete branch)..."
                  if [[ -z "${GH_PAT:-}" ]]; then
                    echo "‚ùå GH_PAT no configurado. Crea el secret GH_PAT para mergear como tu usuario."
                    exit 1
                  fi
                  TITLE=$(gh api "repos/${OWNER_REPO}/pulls/${PR}" --jq .title)
                  GH_TOKEN="$GH_PAT" gh pr merge "$PR" --repo "$OWNER_REPO" --squash --delete-branch --subject "$TITLE"
                  gh pr comment "$PR" --repo "$OWNER_REPO" --body \
                    "‚úÖ **GotaBot:** Merge autom√°tico (1+ comentario, 1+ approval, checks OK)."
                  ;;
                *)
                  echo "‚õî No mergeable todav√≠a (estado: $MERGEABLE_STATE). Se omite."
                  ;;
              esac
            else
              echo "‚è≠ No cumple m√≠nimos (comentarios>=1 y approvals>=1)."
            fi
          done
