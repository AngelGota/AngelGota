name: 2. AutoPullRequest for the feature/*

on:
  schedule:
    - cron: "*/5 * * * *"  # cada 5 min
  workflow_dispatch:
  push:
    branches:
      - 'feature/**'

permissions:
  contents: write
  pull-requests: write

# Evita ejecuciones concurrentes que podr√≠an crear dos PRs a la vez
concurrency:
  group: auto-pr-single
  cancel-in-progress: true

jobs:
  open-prs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      # === Guardia: si ya existe ALG√öN PR abierto desde feature/* -> main, salir ===
      - name: Comprobar si ya hay un PR abierto (feature/* -> main)
        id: guard
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
      
          # Intento principal usando gh pr list (campos v√°lidos)
          COUNT=$(gh pr list --repo "$REPO" --state open --base main \
                    --json headRefName,number \
                    --jq '[ .[] | select(.headRefName | startswith("feature/")) ] | length' || echo 0)
      
          # üß© Fallback por si gh pr list falla o devuelve null
          if [[ -z "${COUNT}" || "${COUNT}" == "null" ]]; then
            echo "‚ö†Ô∏è gh pr list fall√≥, usando fallback con gh api..."
            COUNT=$(gh api -X GET "repos/${REPO}/pulls?state=open&base=main&per_page=100" --paginate \
              --jq '[ .[] | select(.head.ref | startswith("feature/")) ] | length' || echo 0)
          fi
      
          FIRST_NUM=$(gh pr list --repo "$REPO" --state open --base main \
                        --json headRefName,number \
                        --jq '[ .[] | select(.headRefName | startswith("feature/")) ][0].number // ""')
      
          echo "open_feature_prs=$COUNT" >> "$GITHUB_OUTPUT"
          echo "blocking_pr=$FIRST_NUM"  >> "$GITHUB_OUTPUT"
          echo "üîé PRs abiertos feature/* -> main: $COUNT ${FIRST_NUM:+(bloquea #$FIRST_NUM)}"
      
      - name: Crear PRs faltantes (feature/* ‚Üí main) + reviewers
        if: steps.guard.outputs.open_feature_prs == '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          REVIEWERS: AngelGota
          ASSIGNEES: AngelGota
          LABELS: needs-review,auto-pr
        shell: bash
        run: |
          set -euo pipefail

          trim() { echo "$1" | sed 's/^ *//; s/ *$//'; }

          ensure_label() {
            local name="$(trim "$1")"
            local found
            found="$(gh label list --repo "${REPO}" --search "^${name}$" --json name --jq '.[0].name' || true)"
            if [[ -z "$found" ]]; then
              echo "‚ûï Creando label: ${name}"
              gh label create "${name}" --repo "${REPO}" --color "666666" --description "auto" >/dev/null 2>&1 || true
            fi
          }

          # Asegurar etiquetas
          IFS=',' read -r -a LARR <<< "${LABELS}"
          for L in "${LARR[@]}"; do ensure_label "$L"; done

          # Detectar ramas feature/* (URL autenticada por si el repo es privado)
          REMOTE_URL="https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"
          mapfile -t BRANCHES < <(git ls-remote --heads "${REMOTE_URL}" 'refs/heads/feature/*' \
                                  | awk '{print $2}' | sed 's@refs/heads/@@')
          echo "üåø Ramas feature/* detectadas: ${#BRANCHES[@]}"
          printf '%s\n' "${BRANCHES[@]}" | sed 's/^/  - /' || true

          [[ ${#BRANCHES[@]} -eq 0 ]] && { echo "No hay ramas feature/*"; exit 0; }

          git init .
          git remote add origin "${REMOTE_URL}" 2>/dev/null || true
          git fetch --no-tags --quiet origin

          for HEAD in "${BRANCHES[@]}"; do
            [[ -z "$HEAD" ]] && continue

            # 1) ¬øPR abierto ya para esta rama?
            EXISTE=$(gh pr list --repo "${REPO}" --head "${HEAD}" --base "main" --state open \
                       --json number --jq '.[0].number' || true)
            if [[ -n "${EXISTE}" ]]; then
              echo "‚úî Ya existe PR para ${HEAD} (#${EXISTE})"
              continue
            fi;

            # 2) ¬øTiene cambios vs main?
            git fetch --no-tags --quiet origin "${HEAD}" main
            AHEAD=$(git rev-list --left-right --count "origin/main...origin/${HEAD}" | awk '{print $2}')
            echo "‚Üî ${HEAD} ahead de main: ${AHEAD} commits"
            if [[ "${AHEAD}" -eq 0 ]]; then
              echo "‚è≠ Sin cambios vs main en ${HEAD} ‚Äî no se crea PR."
              continue
            fi

            # 3) Crear PR
            echo "‚Üó Crear PR para ${HEAD}"
            gh pr create \
              --repo "${REPO}" \
              --base main \
              --head "${HEAD}" \
              --title "feat: ${HEAD} ‚Üí main" \
              --body "PR autom√°tico generado por auto-pr." \
              --assignee "${ASSIGNEES}" \
              --reviewer "${REVIEWERS}"

            # 4) Etiquetas y salida
            PRNUM=$(gh pr list --repo "${REPO}" --head "${HEAD}" --base "main" --state open \
                      --json number --jq '.[0].number' || echo "")
            if [[ -n "$PRNUM" ]]; then
              for L in "${LARR[@]}"; do
                L=$(trim "$L")
                gh pr edit "${PRNUM}" --repo "${REPO}" --add-label "${L}" || echo "‚ö† No pude a√±adir label ${L}"
              done
              echo "‚úÖ PR #${PRNUM} creado. Se detiene para mantener solo 1 abierto."
              break
            else
              echo "‚ö† PR no encontrado tras crear; se contin√∫a con la siguiente rama."
            fi
          done
